{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","title":"java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类","leftChildren":[{"id":"1c709c905040","title":"线程池的状态","style":{"background-color":"#ffcc99"},"parent":"root","children":[{"id":"16ddfc718f68","title":"RUNNING：创建线程池后，初始时，线程池处于RUNNING状态","style":{"text-align":"right"},"parent":"1c709c905040","children":[],"icons":[{"index":"0","name":"priority"}]},{"id":"1fcf4c99fda5","title":"调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务(包括缓存队列中的任务)执行完毕，然后终止；","style":{"text-align":"left"},"children":[],"parent":"1c709c905040","icons":[{"index":"1","name":"priority"}]},{"id":"8ad7e8be2277","title":"调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；并且清空任务缓存队列，返回尚未执行的任务","style":{"text-align":"left"},"parent":"1c709c905040","children":[],"icons":[{"index":"2","name":"priority"}]},{"id":"b6742271727f","title":"当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态","style":{"text-align":"right"},"children":[],"parent":"1c709c905040","icons":[{"index":"3","name":"priority"}]}],"collapsed":true}],"structure":"mind_free","style":{"font-size":17,"background-color":"#99ffff","font-weight":"bold"},"root":true,"theme":"paper","children":[{"id":"a6895d91ea35","title":"构造函数的参数说明","style":{"font-style":"italic","background-color":"#ffcc99"},"parent":"root","children":[{"id":"930fa1b89dc3","title":"corePoolSize","parent":"a6895d91ea35","children":[{"id":"625fc0bc2cf3","title":"核心线程池的大小","parent":"930fa1b89dc3","children":[],"icons":[{"index":"0","name":"priority"}]},{"id":"9fcd0febdbaf","title":"线程池创建后，默认情况下，线程池中没有任何线程，<br>而是等待有任务到来才会创建线程去执行","style":{"text-align":"center"},"children":[],"parent":"930fa1b89dc3","icons":[{"index":"1","name":"priority"}]},{"id":"2c619af4098f","title":"当线程池中线程数达到corePoolSize后，再有新任务到来，就放到缓存队列中去","parent":"930fa1b89dc3","children":[],"icons":[{"index":"2","name":"priority"}]},{"id":"b4889b8b886d","title":"如果创建线程池后，调用了prestartAllCoreThreads()或者prestartCoreThread()方法，<br>那么在没有任务到来之前就创建corePoolSize个线程或者一个线程","parent":"930fa1b89dc3","children":[],"icons":[{"index":"3","name":"priority"}]}],"collapsed":true},{"id":"5e91d19924f8","title":"maximumPoolSize","children":[{"id":"e1200287e7af","title":"线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；","style":{"background-color":"#ffffff"},"parent":"5e91d19924f8","children":[],"icons":[{"index":"0","name":"priority"}]},{"id":"9f63e6ef167e","title":"maximumPoolSize必须大于等于corePoolSize","style":{"background-color":"#ffffff"},"parent":"5e91d19924f8","children":[{"id":"dce0458f7f3c","title":"这个参数的目的是对核心线程数的一个补充<br>假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。<br>因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；<br>当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；<br>如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；<br>然后就将任务也分配给这4个临时工人做；<br>如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。<br>当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。<br>这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。<br>也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。<br>","style":{"background-color":"#cce5ff"},"children":[],"parent":"9f63e6ef167e"}],"icons":[{"index":"1","name":"priority"}]}],"parent":"a6895d91ea35","collapsed":true},{"id":"04c6f687b5b9","title":"keepAliveTime","parent":"a6895d91ea35","children":[{"id":"3b69eb09e84e","title":"表示线程没有任务执行时最多保持多久时间会终止","children":[],"parent":"04c6f687b5b9","icons":[{"index":"0","name":"priority"}]},{"id":"f63b886f95f6","title":"默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用","parent":"04c6f687b5b9","children":[],"icons":[{"index":"1","name":"priority"}]},{"id":"0086780addef","title":"当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize","children":[],"parent":"04c6f687b5b9","icons":[{"index":"2","name":"priority"}]},{"id":"dd222ba46584","title":"如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0","parent":"04c6f687b5b9","children":[],"icons":[{"index":"3","name":"priority"}]}],"collapsed":true},{"id":"11a8c36fea88","title":"unit","children":[{"id":"f85b24024376","title":"参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性","children":[{"id":"c929ad9d18ec","title":"TimeUnit.DAYS;               //天<br>","children":[],"parent":"f85b24024376","icons":[{"index":"0","name":"priority"}]},{"id":"5618bb0bf93a","title":"TimeUnit.HOURS;//小时","parent":"f85b24024376","children":[],"icons":[{"index":"1","name":"priority"}]},{"id":"15c23de19387","title":"TimeUnit.MINUTES; //分钟","children":[],"parent":"f85b24024376","icons":[{"index":"2","name":"priority"}]},{"id":"32af2300ffa8","title":"TimeUnit.SECONDS; //秒","parent":"f85b24024376","children":[],"icons":[{"index":"3","name":"priority"}]},{"id":"7d6a791e428a","title":"TimeUnit.MILLISECONDS; //毫秒&nbsp;<br>","children":[],"parent":"f85b24024376","icons":[{"index":"4","name":"priority"}]},{"id":"b6f13841df87","title":"TimeUnit.MICROSECONDS; //微妙&nbsp;<br>","parent":"f85b24024376","children":[],"icons":[{"index":"5","name":"priority"}]},{"id":"b8410ef383ff","title":"TimeUnit.NANOSECONDS; //纳秒","children":[],"parent":"f85b24024376","icons":[{"index":"6","name":"priority"}]}],"parent":"11a8c36fea88"}],"parent":"a6895d91ea35","collapsed":true},{"id":"d83b2c484775","title":"workQueue","children":[{"id":"555c9acaa0e2","title":"一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响","children":[{"id":"0eba48421be9","title":"ArrayBlockingQueue基于数组的先进先出队列，此队列创建时必须指定大小；","children":[{"id":"2c83b7d06f17","title":"常用的有两类，一类是遵循FIFO原则的队列如ArrayBlockingQueue与有界的LinkedBlockingQueue，另一类是优先级队列如PriorityBlockingQueue。PriorityBlockingQueue中的优先级由任务的Comparator决定。 \n<br>使用有界队列时队列大小需和线程池大小互相配合，线程池较小有界队列较大时可减少内存消耗，降低cpu使用率和上下文切换，但是可能会限制系统吞吐量。","style":{"background-color":"#99ccff"},"children":[],"parent":"0eba48421be9"}],"parent":"555c9acaa0e2","icons":[{"index":"0","name":"priority"}]},{"id":"9d96ffad9e3b","title":"LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；","parent":"555c9acaa0e2","children":[{"id":"33551e076c51","title":"队列大小无限制，常用的为无界的LinkedBlockingQueue，使用该队列做为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致OOM。最近工作中就遇到因为采用LinkedBlockingQueue作为阻塞队列，部分任务耗时80s＋且不停有新任务进来，导致cpu和内存飙升服务器挂掉。","style":{"background-color":"#99ffff"},"children":[],"parent":"9d96ffad9e3b"}],"icons":[{"index":"1","name":"priority"}]},{"id":"5948cdc84434","title":"synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。","children":[{"id":"b805c451f85f","title":"如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用SynchronousQueue作为等待队列。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。","style":{"background-color":"#99ff99"},"parent":"5948cdc84434","children":[]}],"parent":"555c9acaa0e2","icons":[{"index":"2","name":"priority"}]}],"parent":"d83b2c484775"}],"parent":"a6895d91ea35","collapsed":true},{"id":"90c823cfb52d","title":"threadFactory","parent":"a6895d91ea35","children":[{"id":"e8cd6d87e509","title":"线程工厂，主要用来创建线程","style":{"background-color":"#ffffff"},"children":[],"parent":"90c823cfb52d"}],"collapsed":true},{"id":"d3508060ca12","title":"handler","parent":"a6895d91ea35","children":[{"id":"f731d4d476cc","title":"ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ","parent":"d3508060ca12","children":[],"icons":[{"index":"0","name":"priority"}]},{"id":"125e62f31a62","title":"ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ","children":[],"parent":"d3508060ca12","icons":[{"index":"1","name":"priority"}]},{"id":"824c2ad37a87","title":"ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）","parent":"d3508060ca12","children":[],"icons":[{"index":"2","name":"priority"}]},{"id":"21db06d4108a","title":"ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务","children":[],"parent":"d3508060ca12","icons":[{"index":"3","name":"priority"}]}],"collapsed":true}]}]}},"meta":{"id":"5af25a7fe4b001f7e0cc23c8","member":"587c214ee4b049e7957b8756","exportTime":"2018-05-13 19:53:20","diagramInfo":{"category":"mind_free","title":"Java线程池","created":"2018-05-09 10:18:40","creator":"587c214ee4b049e7957b8756","modified":"2018-05-11 10:31:04"},"type":"ProcessOn Schema File","version":"1.0"}}